
/*
 * This file was generated by Meeduse on Monday, April 24, 2023 at 11:53:34 AM CEST
 */


MACHINE 
	
	schedulerDSL

DEFINITIONS
	


	END_OF_GENERATED_DEFINITIONS_FOR == schedulerDSL;
	
	/*
	 * Start of user code DEFINITIONS (NOT GENERATED)
	 */
	
	/*
	 * End of user code
	 */
	
	

SETS
	
	SCHEDULERCLASS;
	PROCESSCLASS

ABSTRACT_VARIABLES
	
	SchedulerClass,
	ProcessClass,
	Processes,
	Number

INVARIANT
	
	/*
	 * Start of user code INVARIANT (NOT GENERATED)
	 */
	
	/*
	 * End of user code
	 */
	
	
	SchedulerClass : FIN(SCHEDULERCLASS) &
	ProcessClass : FIN(PROCESSCLASS) &
	Processes : ProcessClass +-> SchedulerClass &
	Number : ProcessClass --> INTEGER

INITIALISATION
	
	SchedulerClass := {} ||
	ProcessClass := {} ||
	Processes := {} ||
	Number := {}

OPERATIONS
	
	/*
	 * Start of user code OPERATIONS (NOT GENERATED)
	 */
	update(relation)=
	     PRE relation : ProcessClass +-> StatusEnum
	     THEN PreviousStatus := PreviousStatus <+ (dom(relation) <| Status);
	         Status:= Status <+ relation
	     END ;
	ProcessClass_NEW2(aProcessClass) = 
	PRE	aProcessClass : PROCESSCLASS &
		aProcessClass /: ProcessClass
		
	THEN  
		ProcessClass := ProcessClass \/ {aProcessClass}||
		Status := Status \/ {(aProcessClass |-> Waiting)}
	END;
	UnsetAllStatus(aProcessClass) = 
	PRE	aProcessClass <: ProcessClass
		
	THEN 
		Status := aProcessClass <<| Status
	END;
	
	DeleteProcessWaiting(aProcessClass) = 
	PRE	aProcessClass : ProcessClass &
		Waiting : StatusEnum  &
		{(aProcessClass |-> Waiting)} <: Status
		
	THEN 
		Status := Status - {(aProcessClass |-> Waiting)}
	END;
	/*
	 * End of user code
	 */
	
	
	SchedulerClass_NEW(aSchedulerClass) = 
	PRE	aSchedulerClass : SCHEDULERCLASS &
		aSchedulerClass /: SchedulerClass
		
	THEN 
		SchedulerClass := SchedulerClass \/ {aSchedulerClass}
	END;

	ProcessClass_NEW(aProcessClass,aNumber) = 
	PRE	aProcessClass : PROCESSCLASS &
		aNumber : INTEGER &
		aProcessClass /: ProcessClass
		
	THEN 
		ProcessClass := ProcessClass \/ {aProcessClass} ||
		Number := Number \/ {(aProcessClass |-> aNumber)}
	END;

	SchedulerClass_Free(aSchedulerClass) = 
	PRE	aSchedulerClass : SchedulerClass
		
	THEN 
		SchedulerClass := SchedulerClass - {aSchedulerClass} ||
		Processes := Processes |>> {aSchedulerClass}
	END;

	ProcessClass_Free(aProcessClass) = 
	PRE	aProcessClass : ProcessClass
		
	THEN 
		ProcessClass := ProcessClass - {aProcessClass} ||
		Processes := {aProcessClass} <<| Processes ||
		Number := {aProcessClass} <<| Number
	END;

	result <-- GetProcesses(aSchedulerClass) = 
	PRE	aSchedulerClass : SchedulerClass &
		aSchedulerClass : ran(Processes)
		
	THEN 
		result := Processes~[{aSchedulerClass}]
	END;

	SetProcesses(aSchedulerClass,theProcesses) = 
	PRE	aSchedulerClass : SchedulerClass &
		theProcesses : FIN(ProcessClass) &
		(theProcesses * {aSchedulerClass}) /<: Processes &
		!added.( added : theProcesses => Processes[{added}] = {})
		
	THEN 
		Processes := (Processes |>> {aSchedulerClass}) \/ (theProcesses * {aSchedulerClass})
	END;

	UnsetProcesses(aSchedulerClass) = 
	PRE	aSchedulerClass : SchedulerClass
		
	THEN 
		Processes := Processes |>> {aSchedulerClass}
	END;

	AddProcesses(aSchedulerClass,aProcesses) = 
	PRE	aSchedulerClass : SchedulerClass &
		aProcesses : ProcessClass &
		(aProcesses |-> aSchedulerClass) /: Processes &
		Processes[{aProcesses}] = {}
		
	THEN 
		Processes := Processes \/ {(aProcesses |-> aSchedulerClass)}
	END;

	RemoveProcesses(aSchedulerClass,aProcesses) = 
	PRE	aSchedulerClass : SchedulerClass &
		aProcesses : ProcessClass &
		(aProcesses |-> aSchedulerClass) : Processes
		
	THEN 
		Processes := Processes - {(aProcesses |-> aSchedulerClass)}
	END;

	result <-- GetNumber(aProcessClass) = 
	PRE	aProcessClass : ProcessClass &
		aProcessClass : dom(Number)
		
	THEN 
		result := Number(aProcessClass)
	END;

	SetNumber(aProcessClass,aNumber) = 
	PRE	aProcessClass : ProcessClass &
		aNumber : INTEGER
		
	THEN 
		Number := ({aProcessClass} <<| Number)  \/ {(aProcessClass |-> aNumber)}
	END


END
